// lookup access
#define USES_BPF_MAPS
#define COMMON_MAPS
#define USES_BPF_MAP_LOOKUP_ELEM
#define USES_BPF_MAP_UPDATE_ELEM
#define USES_BPF_RINGBUF_RESERVE
#define USE_BPF_RINGBUF_OUTPUT


#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include "../../verification_tools/common.h"
#include "klee/klee.h"


struct bpf_map_def SEC("maps") ringbuf_map = {
	.type = BPF_MAP_TYPE_RINGBUF,
	.max_entries = 4,
};

struct bpf_map_def SEC("maps") lookup_map = {
	.type = BPF_MAP_TYPE_ARRAY,
	.key_size = sizeof(__u32),
    .value_size = sizeof(__u32),
	.max_entries = 2,
};


#define CACHE_SIZE 1031

SEC("socket")
int socket_handler(struct __sk_buff *skb)
{

    void *ptr1 = bpf_ringbuf_reserve(&ringbuf_map, 0, (unsigned long long)0xffffffffffffffff);
    
    volatile long r9_val = (long)ptr1;
    r9_val += CACHE_SIZE;

    if(ptr1) {
        bpf_ringbuf_discard(ptr1, 0);
        return 0;
    }

    r9_val++;

    __u32 key = 0;
    void *value = bpf_map_lookup_elem(&lookup_map, &key);
    if (!value) {
        return 0;
    }

    bpf_ringbuf_output(&ringbuf_map, value, r9_val, 0);

    return skb->len;
}


int main()
{
    // create sk_buff
    struct __sk_buff *skb = create_packet(sizeof(struct __sk_buff));

    // initialize map
    // No initialization needed for ringbuffer
    // BPF_MAP_INIT(&ringbuf_map, "ringbuf_map", "", "");
    BPF_MAP_INIT(&lookup_map, "lookup_map", "", "");

    // add initial required entry to lookup_map
    __u32 idx = 1;
    __u32 val = 1;
    bpf_map_update_elem(&lookup_map, &idx, &val, BPF_ANY);

    // call the ebpf function
    socket_handler(skb);
    
    return 0;
}